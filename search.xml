<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无稽之谈]]></title>
    <url>%2F%E6%97%A0%E7%A8%BD%E4%B9%8B%E8%B0%88%2F</url>
    <content type="text"><![CDATA[关于“割韭菜” 我一直都认为“割韭菜”这个词用的不赖！因为如果说是要割些别的蔬菜，割完就没有了，但是韭菜割完还会长，割完一轮还有一轮；如果说是割草，虽说草这玩意烧不尽，而且割完还能吹又生，但是草里藏着只泥马，不好惹啊！ 关于“生活的目的” 我经常忍不住要思索“生活的目的”，总觉得人不能漫无目的的做布朗运动。从小到大，无论是别人告诉我的、书上写的、电视上播的，给出的答案大多都是“活着就好”的意思。最初我很迷信这个答案，就跟迷信课本和试卷上的所有标准答案一样，但是后来有了点生活经验就起了疑心。我是在农村长大的，看过别人家养猪或者养别的什么，我发现养猪的人很不希望猪瞎折腾不长肉，因为卖不了好价钱。猪发现自己一折腾起来就会被打的嗷嗷叫，就老实了，觉得活着就好，然后就吃了睡睡了吃。虽说人就是人，猪就是猪，不应该互相拿来做比较，但这个答案差不多就是这个意思。后来不知道哪位作家很过意不去，就发明了“猪栏哲学”，劝大家不要过这样的生活，然后这个答案又有了新的形式，叫”好好的活着”！我的想法倒是很简单，人不要像猪或者宠物那样活着，人首先要让自己活得痛快，然后再考虑别的什么，要是有人不乐意，你把他送走就完了。。。 关于说话 在说话上我一直有点摸不着头脑，老是惹的对方不高兴。我就去找原因，最初我找了个漂亮的借口——一定是因为我“说话不经过大脑”。学过生物的人都知道人说话要经过大脑皮层的语言中枢，不经过大脑的话根本就说不出话来，比如有些语言中枢损坏的人就得了失语症，所以这个说法怕是不成立。那是不是因为我的脑子有点问题呢？这个还真不好说，因为长这么大也没做过精神病的鉴定，一口咬定自己大脑没问题恐怕缺少说服力。当然了我觉得即使我有精神病应该也不严重，不然肯定早被人送到精神病院去了！那是不是说话地点不对，好像也不是，我曾经以为大学是个说话自由的地方，自由的说话是种时尚，还能促进新知，当然这就像乌托邦一样不大现实，有人的地方就有江湖嘛！后来我突然想到了什么，以前在行署大院见过一只会学舌的鹦鹉，你说一句它就说一句，有人能一直逗它还乐此不疲，当然了你要是逗一只乌鸦就没这么有趣了。我不愿意说话像一只乌鸦惹人厌，但是做只鹦鹉简直不可能，所以在说话方面一直没什么长进，索性就泯然为沉默的大多数好了！ 关于书籍 我一直偏爱两类书籍，一类书籍就像镜子，充满着智慧，让你觉得你的脖子上长了个猪头，这么说有点像照妖镜，哈哈，但猪其实是很聪明的动物，所以才能成为动物农场里的主宰；另一类书籍就像厨子，刀法了的，这时的你就像一头待宰的牛，还没回过神来，就发现他已经在摸你身上的纹理，有时候也摸摸自己的。你感觉有点像挠痒痒，忍不住要笑，感到疼再转过头来的时候，发现他已经在你身上动刀子了！]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Udacity无人车开发环境]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAUdacity%E6%97%A0%E4%BA%BA%E8%BD%A6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[“万事开头难”，搭建开发调试环境既是垫脚石，也是拦路虎，不管是一气呵成，还是费尽周章，事后做好记录都是明智之举，可以避免不必要的重复劳动。这篇博客主要记录在win10_64位下基于CPU或者GPU搭建Udacity无人车开发环境的大致过程。 安装Anaconda 开发python程序经常要涉及第三方库，很容易出现版本混乱和各种不兼容的问题，因此可以安装conda来帮我们管理软件包和依赖，使项目开展更加顺利。由于我只需要最基本的功能，所以选择了安装miniconda，下载地址如下： https://repo.continuum.io/miniconda/Miniconda3-latest-Windows-x86_64.exe 常用的conda命令可以参考官方的用户指南官方的用户指南。 conda换源 为了提高conda安装的速度，我们可以将conda的源换成科大或是清华的： conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 然后把.condarc中channels下面的-defaults这一行删掉，正确的结果如下： channels: - https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ - https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ - https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ show_channel_urls: true 此外还要做点准备，将CarND-Term1-Starter-Kit仓库下载到本地，进入项目目录，将meta_windows_patch.yml重命名为meta.yml： git clone https://github.com/udacity/CarND-Term1-Starter-Kit.git cd CarND-Term1-Starter-Kit 基于CPU搭建 基于CPU搭建Udacity无人车开发环境比较简单， 只要根据environment.yml创建carnd-term1就行了： conda env create -f environment.yml conda info --envs 查看是否创建成功 conda env remove -n carnd-term1 卸载环境 environment.yml文件具体内容如下，我在测试中发现缺少requests模块，所以添加了一行’- requests’，也可以之后用conda install requests来单独安装： name: carnd-term1 channels: - https://conda.anaconda.org/menpo - conda-forge dependencies: - python==3.5.2 - numpy - matplotlib - jupyter - opencv3 - pillow - scikit-learn - scikit-image - scipy - h5py - eventlet - flask-socketio - seaborn - pandas - ffmpeg - imageio=2.1.2 - pyqt=4.11.4 - requests - pip: - moviepy - tensorflow==1.3.0 - keras==2.0.9 基于GPU搭建 基于GPU搭建Udacity无人车开发环境需要考虑的问题较多，但“工欲善其事，必先利其器”，使用GPU来训练神经网络模型相比CPU在速度上至少有几十倍的提升，因此该折腾还得折腾。我这里使用的GPU是Nvidia的GTX 1060 6G，在安装tensorflow-gpu之前，需要先安装CUDA Toolkit、cuDNN和必要的显卡驱动。CUDA Toolkit 和cuDNN的版本要与tensorflow-gpu相适应，可以参照Tensorflow官网经过测试的源代码配置来选择适合你的版本。我这里选择的是tensorflow_gpu-1.3.0，cuDNN v6.0和CUDA Toolkit 8.0，需要注册登陆Nvidia开发者账号才能下载。 # cuDNN v6.0 下载地址 https://developer.nvidia.com/rdp/cudnn-archive#a-collapse6-8 # CUDA Toolkit 8.0 下载地址 https://developer.nvidia.com/compute/cuda/8.0/Prod2/network_installers/cuda_8.0.61_win10_network-exe Visual Studio 2012 安装 需要注意的是， 在安装CUDA Toolkit之前，还需要先安装Visual Studio，通过运行一些例程来测试GPU是否已经准备就绪。我这里下的是体积适中的Visual Studio 2012，参考博客Microsoft Visual Studio 2012旗舰版(VS2012中文版下载)官方中文版，比较杯具的是C盘空间不够，只能从D盘腾挪了几十G过来，呵呵！ # Microsoft Visual Studio 2012 下载地址 http://download.microsoft.com/download/B/0/F/B0F589ED-F1B7-478C-849A-02C8395D0995/VS2012_ULT_chs.iso # 序列号：YKCW6-BPFPF-BT8C9-7DCTH-QXGWC CUDA Toolkit 8.0 安装 CUDA Toolkit 8.0 安装比较简单，按照提示一步步操作就可以，我下载的是网络版的，只要确保电脑能上网就行。安装驱动过程中画面会出现几次闪烁熄屏，是正常现象。 cuDNN v6.0 安装 把下载下来的安装包解压到CUDA的安装路径(默认C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0)的目录下，然后在Windows环境变量Path中添加动态链接库cudnn64_6.dll的路径(默认是C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\cudnn-8.0-windows10-x64-v6.0\cuda\bin), 重启生效就可以了。 GPU环境测试 Visual Studio 2012、CUDA Toolkit 8.0、cuDNN v6.0都安装好后，可以用Visual Studio 2012打开（默认路径C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0）下的Samples_vs2012.sln工程，将1_Utilities文件夹下的deviceQuery右键设为启动项目，然后直接开始执行不调试，得到下图结果就可以了。其它例程有兴趣也可以运行看看效果。 安装tensorflow-gpu 根据environment-gpu.yml创建carnd-term1： conda env create -f environment-gpu.yml 由于安装过程中报错： tensorflow_gpu-1.3.0-cp35-cp35m-linux_x86_64.whl is not a supported wheel on this platform. 发现tensorflow_gpu-1.3.0-cp35-cp35m-linux_x86_64.whl不是为windows系统准备的，所以将environment-gpu.yml中替换成了tensorflow_gpu-1.3.0-cp35-cp35m-win_amd64.whl，由于是要访问国外的网站，需要翻墙并开启全局代理，网速可能不太稳定，有时候还会连不上，做好心理准备。 environment.yml文件具体内容如下: name: carnd-term1 channels: - https://conda.anaconda.org/menpo - conda-forge dependencies: - python==3.5.2 - numpy - matplotlib - jupyter - opencv3 - pillow - scikit-learn - scikit-image - scipy - h5py - eventlet - flask-socketio - seaborn - pandas - ffmpeg - imageio=2.1.2 - pyqt=4.11.4 - requests - pip: - moviepy - https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.3.0-cp35-cp35m-win_amd64.whl - keras==2.0.9 终极测试 基于CPU或者GPU搭建好无人车开发环境carnd-term1后，可以进行最后的测试。首先，下载我们要运行的测试环境的仓库： git clone https://github.com/udacity/CarND-Term1-Starter-Kit-Test.git cd CarND-Term1-Starter-Kit-Test 然后激活conda的carnd-term1环境后运行jupyter notebook： activate carnd-term1 jupyter notebook test.ipynb 浏览器会自动跳转到 http://localhost:8888/notebooks/test.ipynb 网址，经测试，jupyter notebook的每个单元都能够正常执行，没有错误，说明Windows环境下的carnd-term1已经完全ok了。效果图如下： 总结 “好的开始是成功的一半”，搭建好开发环境后，我们就可以专注于学习无人车相关的知识和编程实现上了。Perfect!]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡尔曼滤波]]></title>
    <url>%2F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[卡尔曼滤波对机器人研究来说是一个比较常用的方法，这篇博客主要根据CS373: Artificial Intelligence for Robotics这门公开课的内容做简要的介绍。 高斯分布 高斯分布是一个连续的单峰图像（continuous, uni-model)，如下图所示，表示的是一个概率分布。高斯分布可以通过均值μ和方差σ^2来共同确定它的位置和形状。当x=μ时，f(x)有最大值；σ^2越大，图像越矮胖，不确定性越大，反之亦然。 用数学公式描述如下：$$ f(x) = \frac{1}{\sqrt{2πσ^2}} exp^{-\frac12 \frac{(x-μ)^2}{σ^2}} $$ $$ \int_{-\infty}^\infty f(x)dx = 1 $$ Measure Gaussian 在prior Gaussian的基础上，我们结合measure Gaussian就可以得到一个new Gaussian, 如下图所示： 用数学公式描述如下：$$ μ^{‘}= \frac{μr^2+vσ^2}{r^2+σ^2} $$ $$ σ^{2’}= \frac{1}{\frac{1}{r^2}+\frac{1}{σ^2}} $$ Predict Gaussian 在prior Gaussian的基础上，我们可以得到一个motion Gaussian，如下图所示： 用数学公式描述如下：$$ μ^{‘}= μ + v $$ $$ σ^{2’}= σ^2 + r^2 $$ 卡尔曼滤波 卡尔曼滤波是一个动态更新的循环过程，包括测量和预测两个部分，我们可以通过线性代数来描述卡尔曼滤波的计算过程（包括一维和二维），如下： 其中，F表示状态转换矩阵，H表示测量函数。 测量部分$$ x^{‘}= Fx + u $$ $$ P^{‘}= F•P•F^T $$ 预测部分$$ y = Z - H•x $$ $$ S = H•P•H^T + R $$ $$ K = P•H•S^{-1} $$ $$ x^{‘}= x + (K•y) $$ $$ P^{‘}= (I - K•H)•P $$ 其中， x表示状态的估计值，u表示运动矢量，P是用于表示不确定性的协方差矩阵，Z表示测量值， R表示测量，I表示单位矩阵。举个例子来说明这些矩阵应该如何取值：123456789101112131415161718192021222324252627282930313233343536# 2-Dmeasurements = [1, 2, 3]x = matrix([[0.], [0.]]) # initial state(location and velocity)P = matrix([[1000., 0.], [0., 1000.]]) # initial uncertaintyu = matrix([[0.], [0.]]) # external motionF = matrix([[1., 1.], [0, 1.]]) # next state functionH = matrix([[1., 0.]]) # measurement functionR = matrix([[1.]]) # measurement uncertaintyI = matrix([[1., 0.], [0., 1.]]) # identity matrix# 4-Dmeasurements = [[1., 17.], [1., 15.], [1., 13.], [1., 11.]]initial_xy = [1., 19.]dt = 0.1x = matrix([[initial_xy[0]], [initial_xy[1]], [0.], [0.]]) # initial state (location and velocity)u = matrix([[0.], [0.], [0.], [0.]]) # external motion# initial uncertainty: 0 for positions x and y, 1000 for the two velocitiesP = matrix([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 1000., 0.], [0., 0., 0., 1000.]]) # next state function: generalize the 2d version to 4dF = matrix([[1., 0., dt, 0], [0., 1., 0., dt], [0., 0., 1., 0.], [0., 0., 0., 1.]]) # measurement function: reflect the fact that we observe x and y but not the two velocitiesH = matrix([[1., 0., 0., 0.], [0., 1., 0., 0.]]) # measurement uncertainty: use 2x2 matrix with 0.1 as main diagonalR = matrix([[0.1, 0.], [0., 0.1]])I = matrix([[1., 0., 0., 0], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) # 4d identity matrix 卡尔曼滤波常用于传感器的数据融合和物体追踪之类的问题，而且由于计算量不大，被广泛应用于工程领域。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器人</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录我的入职拓展培训]]></title>
    <url>%2F%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%85%A5%E8%81%8C%E6%8B%93%E5%B1%95%E5%9F%B9%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[7月20日—7月21日，伙伴们参加了所里在浙江嘉兴平湖澳多奇农庄举办的新员工拓展培训活动。此时正值盛夏，天气十分炎热，但是身着橙色服装的苍穹队伙伴们依旧热情不减，满满的活力。 经过短暂的热身之后，各队首先展开了水果“连连看”比赛的争夺，游戏规则比较简单，但考验的是团队成员的协作与智慧。各队分别派两名队员轮番上阵，不断翻开斗篷并将相同的水果揽入名下，苍穹队也不甘示弱，越战越勇，最终获得了并列第二的成绩。 下午时分，“传国玉玺”的出现引爆了“六大门派”的厮杀，这是一场胜者为王的游戏，共设立六重关卡。在队长的带领下，大家集体行动，积极献策，轻松通过了平衡钉子、叠纸杯、集体跳绳、气球承重等环节；解十字结的时候遇到了难题，但大家坚持到最后，决不放弃；成语“你画我猜”环节，一次通过，充分展现了团队成员间的默契配合。虽然时间上不占优势，没有取得较好名次，但是苍穹队秉承坚持不懈的精神，我们坚信这样做才是最棒的。 印象最深的，当属团队在晚宴上的精彩表现。我们队共准备了3个节目，大家利用休息间隙争分夺秒的准备和排练，不断的改进。小品《面试》让人捧腹，现场笑声不断；王腾杰个人独唱《动物世界》，神似薛之谦，引来大家叫好；朗诵作品大气磅礴，气势恢弘。最终我们队力压群芳获得了团队一等奖，这是大家齐心协力的结果，有点出乎意料之外，又似乎在情理之中。 第二天搭“呼吸机”吹爆气球的比赛也十分精彩，各队都玩的不亦乐乎。拓展培训好玩又有趣，磨合了大家，建立了友谊。未来在上电所的大家庭里，我们将齐心合力，梦想不止，迈向苍穹！]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的手机摄像头成为jupyter的眼睛]]></title>
    <url>%2F%E8%AE%A9%E4%BD%A0%E7%9A%84%E6%89%8B%E6%9C%BA%E6%91%84%E5%83%8F%E5%A4%B4%E6%88%90%E4%B8%BAjupyter%E7%9A%84%E7%9C%BC%E7%9D%9B%2F</url>
    <content type="text"><![CDATA[摄像头作为视觉的入口，无论学习图像处理还是视频聊天都必不可少。本着物尽其用的原则，我决定把我的手机摄像头开放给我的台式主机使用，主要是希望能够在jupyter上访问用来做图像处理。经过在网上的一番搜索和我自己的摸索实践，找到了一个行之有效的方案。 DroidCam DroidCam可以把你的安卓设备虚拟成无线的网络摄像头，方便PC端的QQ、Skype等软件视频聊天的时候使用。也可以通过浏览器输入IP的方式来访问，十分方便易用。到Play商店搜索DroidCam Wireless Webcam可以下载安卓客户端，到官网Dev47Apps可以下载Windows客户端DroidCam.Client.6.0.FullOffline.exe。 首先要确保PC和手机在同一个wifi网络下再打开PC客户端和app，然后把app上显示的IP地址和端口号（默认4747，可以在Setting中修改）填入PC客户端，就可以点击Start/Connect连接了。 还可以在web浏览器端输入http://…URL来访问。 jupyter访问摄像头通过OpenCV的VideoCapture类来实现12345678910111213import cv2# 注意将xxx换成你app上的IP地址video_path = 'http://xxx:4747/video'cap = cv2.VideoCapture(video_path)# cap = cv2.VideoCapture(0) while(cap.isOpened()): ret, frame = cap.read() cv2.imshow('frame',frame) if cv2.waitKey(1) &amp;0xFF == ord('q'): breakcap.release()cv2.destroyAllWindows() 上述程序在视频显示窗口中按下q键即可断开视频传输。好处是很容易编程进行图像处理，缺点是视频窗口单独显示，使用起来不太方便。 通过HTML直接内嵌在网页中12345678from IPython.display import HTML# 注意将xxx换成你app上的IP地址HTML("""&lt;body&gt; &lt;img style="-webkit-user-select: none;" src="http://xxx:4747/video" width="389" height="291"&gt;&lt;/body&gt;""") 好处是视频图像可以直接在网页上实时显示，缺点是不方便编程进行图像处理。 牛刀小试 我用的是HMD出的Nokia7的前置500万像素摄像头，为了试试这个手机版的网络摄像头好不好使，我决定用Haar Cascades检测人脸和眼睛的代码来测试一下。需要将haarcascade_frontalface_default.xml和haarcascade_eye_tree_eyeglasses.xml这两个文件下载到工程根目录下，代码实现比较简单，就不细说了，如下：12345678910111213141516171819202122232425262728import cv2import numpy as npface_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')eye_cascade = cv2.CascadeClassifier('haarcascade_eye_tree_eyeglasses.xml')# 注意将xxx换成你app上的IP地址video_path = 'http://xxx:4747/video'# cap = cv2.VideoCapture(0)cap = cv2.VideoCapture(video_path)while(cap.isOpened()): ret, img = cap.read() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_cascade.detectMultiScale(gray) for (x, y, w, h) in faces: cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2) roi_gray = gray[y:y+h, x:x+w] roi_color = img[y:y+h, x:x+w] eyes = eye_cascade.detectMultiScale(roi_gray) for (ex, ey, ew, eh) in eyes: cv2.rectangle(roi_color, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2) cv2.imshow('img',img) if cv2.waitKey(1) &amp;0xFF == ord('q'): break cap.release()cv2.destroyAllWindows() 可以看到，用手机摄像头来捕捉人脸和眼睛的效果还是不错的，虽然实验过程中会有点网络延迟，但是总体影响不大，用来替代市面上的一些网络摄像头还是可行的，哈哈！ 总结 这次实验给我的启发：可以在手机端运行一个web服务器，并让这个web服务器来管理手机各类硬件资源，这样只要通过浏览器jupyter就可以直接访问了！唯一的问题就是要特别注意网络安全问题，最好可以设置下账号密码！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业旅行之嗨到张家界]]></title>
    <url>%2F%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E4%B9%8B%E5%97%A8%E5%88%B0%E5%BC%A0%E5%AE%B6%E7%95%8C%2F</url>
    <content type="text"><![CDATA[毕业设计答辩结束以后，我跟好友就立马动身前往此次毕业旅行的目的地-张家界，说来离菲哥家乡恩施倒是蛮近的。从6月7日到6月12日，来回车程2天，所以有效游览时间只有4天，时间还是比较紧凑的，其中3天都在张家界·武陵源一带度过，最后1天上午游览了黄龙洞，下午登天门山。虽然时隔多日，但那些如梦似幻的景色却都还在眼前，因此打算趁闲暇时光以一篇游记的形式拾起这些精彩的画面和记忆。 旅行前准备 “凡事预则立，不预则废”，旅行前几天我们就在知乎和马蜂窝等网站上仔细研究了一些攻略，并记录了一些注意事项。除了旅行必备的用品、订车票和旅店这些琐事，最重要的就是对游览路线进行了大致的规划。具体的思路是顺时针方向从森林公园门票站进入，途经黄石寨、袁家界、杨家界、天子山，最后从索溪峪门票站出。沿途安排住宿和补给，景点内部以徒步为主，景点之间搭乘环保车。然后最后一天将黄龙洞中的奇观、天门山的索道和玻璃栈道等一网打尽，哈哈，这样一来不在计划中的也就只有大峡谷的玻璃桥啦！想法还是很美好的，现实是将近一百公里的山路行走双腿酸爽到爆炸！ 黄石寨 从森林公园门票站进入后的第一个景点就是黄石寨。黄石寨上行人稀少，大概是因为景色平平，山路折返又十分费时费力。反而不时出没的野生猕猴在频频宣示主权，很有占山为王的意思。本来各自相安无事，直到我失手弄坏了书包，这群小猴子才临时起了乘火打劫之意，所幸在聪人的棍棒加持下没敢轻举妄动，但是事后表明野猴也不是好惹的。留下打油诗一首：“黄石寨上行人稀，无心惹猴群起意。聪人小胜猕狲散，卷土重来未可欺。” 袁家界 从黄石寨下来之后，我们在氧气吧广场附近找了个亭子打算休息并补充能量。环顾四周，有不少猴子穿行于游人之中，眼前一只似乎在放哨的猴子使我们感到不安。因此没有过多停留，我们便按计划继续沿金鞭溪漫步前行。林木苍翠欲滴，溪水潺潺，稍抬头便可见怪石嶙峋的险峰，俯视皆是风景，十分惬意，难怪《西游记》会在此取景。直到行至一小桥时，两只壮年野生大猕猴打破了平静，袒胸露懒作威胁状，我们想驱赶它们，但棍棒威吓无用，反而惹怒了它们直奔我们而来。我们退到人群中想要混迹过去，冷不防猴子还是跳到我书包上，拿了两个面包扬长而去，虚惊一场，早知如此，何必如此阵仗！接着我们沿乱窜坡上袁家界，乱窜坡真是左冲右突，陡峭又漫长，不过正如古人言“世之奇伟瑰怪，非常之观，常在咸远，非有志者不能至也”，事实证明，袁家界才是最不负此行的神仙之境！在观景台上驻足远望，石峰林立，形貌万千，像是一场巨人的盛会，很有想纵身一跃去聆听他们谈话的冲动，我想歌曲《我从崖边跌落》中的想象放在这里再合适不过了。介绍上说，经过亿万年流水的冲刷、风力的侵蚀和山体在重力作用下的崩塌，才形成了张家界如此独一无二的喀斯特地貌，然而我想说成就这大手笔的除了自然的造作，还有生命的张力。这里有阿凡达“悬浮山”的取景地哈利路亚山，非常完美，不可方物，有横跨两峰之间的“天下第一桥”，令人称奇、赞叹、流连。 天子山 第一天游完黄石寨和袁家界后我们便到天子山镇的观田园客栈落脚，老板招待比较周到，有求必应。傍晚我们带上几罐啤酒在镇上闲逛，到处都在兴建各色酒肆客栈，旅游成了小镇的主题。比较意外的是，我的手机突然报废，啥都不说了，魅族一生黑！第二天一早，与计划稍有不同的是，我们打算先游览天子山的神堂湾和大观台。神堂湾上的石峰更密集，雾气还没有散去，似有千军万马之势，但是对我们的视觉冲击很有限了，因此我们决定下山去看看，也许有另一番风景。大观台那里据说观看日出很美，当然时间不允许我们这样做了。大致下到山麓的位置，我们尝了当地的特色小吃-葛根粉，和家乡那边的仙草冻有点像。这里好多地方都是应景取的名字，比如神鸡啄食、一步难行和仙人桥，包括天子座。神鸡啄食那往远处看就是，一步难行则是要跨越一深堑，仙人桥则是一个天然形成的石桥，只可远观。这几个景点都还不错，但是印象最深刻的还是天子座，由于地势上的一个小落差，视野非常开阔，有睥睨天下之感受，有飞仙遨游之遐想，在这里吃午餐确实是极致的享受，还没有人来打扰。 杨家界 下午时分，环保车始终座满，我们就打车来到了杨家界，并将行李放在一个土家族夫妻开的旅店里，轻装简行去乌龙寨。乌龙寨还是蛮有特色的，环绕着一座石峰而建，因此比较陡峭湿滑，有个叫一线天的地方只容许一人侧行而过，对胖的人估计是个挑战了。人们在这里修建了一些铁制的扶梯，使得游客可以到达乌龙寨的顶部，也就是天波府，我们到达的时候阳光很温和，天空开始有些乌云，并下了点小雨。由于路途太远我们中途放弃一步难行，并回到旅店休息，等待天然长城上7点半的日落。应该说，天公还算作美，一轮绚烂的落日从乌云中挣脱，将天空的脸颊染的绯红，然后缓缓落下隐匿于万山丛中，壮阔得让人心潮澎湃。比较遗憾的是，5点早起看日出的时候才发现地点不合适，因此只得作罢。 金鞭溪 我们从杨家界出发，径直到天子山的贺龙公园下车。为了避开旅行团，只略作停留，我们便打算赶往十里画廊，人们常说下山容易山上难，可是面对这七八公里百转千回的山路，我的双腿已经开始不自主的颤抖好像要献出膝盖一般。一路下来，我们走走停停，没有特别的风景，只是那些石峰近的可以观察出岩石的层层叠叠的纹理。这样，我们临近中午才抵达十里画廊，这里有小火车，游人如织。猴园里那些被关着的猴子的生存状态，以及迎面袭来的刺鼻气味，都让人十分的不舒服，因此我们很快就离开了。傍着小火车和车上游客的喧嚣，行走在十里画廊的步道上欣赏沿途的风景，平缓的道路让我们的脚踝十分的放松。在意料之外的是，索溪峪是个自然保护区，因此我们只是在环保车上欣赏了它那翡翠般碧绿的湖泊。眼看离傍晚还有几个钟头，我们决定返回游览金鞭溪的下游。人们大多在水绕四门附近玩水，我们打算宿溪而上，溪水清冽冰凉，鱼儿穿行其中，鹅卵石湿滑，一个外国的姑娘在前方落水。行走大概1.5公里，我在翻越一道堤坝时，不慎被植物蜇伤，然后聪人也躺枪，哈哈，感同身受，同理心的最高境界！不过好处是脚踝得到了按摩式的放松，很快便褪去了这几日累积的酸痛和疲惫。 黄龙洞 从索溪峪到黄龙洞有一个小时的车程，我们到达的时候已是上午9点，正是旅行团扎堆的时间节点，平生第一次探洞，迫不及待，没办法，只能焦急等待。大概10点钟，我们才进入洞中，虽然外面很炎热，但是洞中却有点寒意。洞中遍布着大大小小的钟乳石，被灯光映照得五颜六色，印象比较深刻的是那个能容纳15个人的像拇指一般的大型钟乳石，还有闻起来使人能联想起异形卵的一种怪骚味。钟乳石最多的当数夹在两条地下暗河之中的洞中洞，乳白色，满目皆是，触手可及。许多地方因为顶部坍塌形成了像穹顶一样的结构，还有倾泻而下的洞中瀑布。我们坐船穿行于一层水洞，真是一种神秘的在《饥荒》里没有的体验哈，最终沿一狭长的仅有一人高的小道离开，行程大概要2、3个小时。出来之后，我长舒一口气，将那种幽闭的压抑抛之脑后。 天门山 天门山的7.5公里索道，在张家界市区抬头就能看到，十分的诱人，就是排队长的令人发指！如此长的距离，再加上大倾角的设计，天门山峻峭的灰质岩，机械和自然之美在此融合，十分刺激人的感官。反倒是备受期待的玻璃栈道反而无感，毛玻璃的既视感，不过沿着崖壁而建的鬼谷栈道还是值得游览的啦！捭阖仿佛是臭虫的乐园，天门洞开之处据说有飞机飞过，陡峭的阶梯已经安装了扶手，本以为到此一切都已经结束，谁曾想下山的盘山公路如此极限刺激，司机的车技显然已经超神，但是我的耳朵却缓了好久才恢复过来! 建议 1.张家界是一个比较热门的旅游城市，因此车站附近、沿途商铺、景区门口拉客宰客现象比较严重，建议不要搭理他们，免得纠缠不清。 2.山上的旅店住宿条件较差，洗澡只能用非常冰冷的水，然后被子也潮湿得让人难以入眠，十分僵硬。 3.用学生证买优惠门票需要到景区门票站，而且只能用现金或者刷卡，不是很方便！ 行文至此，不知不觉已多言。本来是打算写成游记的，不小心写成了攻略，哈哈！旅途往往会带来丰富的体验和感受，当然也会发生很多意料之外的事情。还要感谢有聪人一路同行，《围城》里有句有意思的话是“经过长期苦旅行而彼此不讨厌的人，才可以结交作朋友”。希望以后有机会能够一同到更多的地方去旅行，比如敦煌，比如贝加尔湖。转眼之间已毕业，不禁感慨：风景和人或许都会离去，但是那些经历会沉淀下来使你丰富！]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无人驾驶之车道线检测]]></title>
    <url>%2F%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E4%B9%8B%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[介绍 这是Udacity无人驾驶第一学期的第一个项目–车道线检测，项目要求从所提供的道路图像和视频流中识别并标注出左右两侧的车道线。课程方提供了完成这个项目所需的ipynb工程模板、示例和相关素材，我们可以从Github上找到udacity/CarND-LaneLines-P1，下载到本地并进入项目文件夹： git clone git@github.com:udacity/CarND-LaneLines-P1.git cd CarND-LaneLines-P1 启动之前建立的Anaconda的carnd-term1环境和jupyter页面: activate carnd-term1 jupyter notebook 可以跳转到浏览器端的jupyter页面，点击P1.ipynb就可以进入项目的编程界面。课程方已经为我们提供了程序的框架，并封装了一些辅助函数(主要是cv2的API)，需要我们实现的有两个部分，一个是车道线检测的流程process_image 函数，还有一个是用于车道线标注的draw_lines函数。下文将主要记录我的实现思路，具体代码托管在我的github上。 git@github.com:hewangxing/CarND-LaneLines-P1.git 车道线检测 识别车道线的程序像流水线一样，分为以下六个步骤： 第一步，将彩色图像image转换为灰度图像，grayscale(); 第二步,对灰度图像进行高斯滤波，抑制噪声, gaussian_blur(); 第三步，运用Canny算子进行边缘提取，canny(); 第四步，选择图像中的感兴趣区域ROI，region_of_interest(); 第五步，通过霍夫变换检测直线并标注，hough_lines(); 第六步，图像叠加显示最终结果，weighted_img()。 车道线标注 通过霍夫变换得到的是一些线段，我们希望用两条实线分别表示左右车道线，因此需要修改draw_lines函数。实现思路：首先通过直线斜率或者倾斜角对左右线段进行分类，然后求均值并计算左右直线方程，用np.poly1d计算出靠近ROI边界的端点坐标，最后用cv2.line画出左右车道线。 问题和改进 程序最初是针对test_images中的道路图像进行开发的，功能实现后就填充到process_image()用于视频中车道线的检测。经过测试和修改，在solidWhiteRight.mp4和solidYellowLeft.mp4中运行效果良好，但在稍复杂的challenge.mp4中的表现就差强人意了，一方面是由于背景中有较多干扰线段出现，另一方面部分路段颜色与黄色车道线较难区分。因此，还需要在算法的稳健性上下点功夫，也说明了手动调节参数很难保证程序的通用。 编程中遇到的一些其它问题： 1.视频程序运行几遍后经常奔溃OSError, 解决办法是Kernel-&gt;Restart &amp; Clear Output, 然后重新运行Run All。 2.一些opencv的API、python第三方库等不熟悉，使用出错，比如数组的维度不匹配等。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给无人驾驶热降降温]]></title>
    <url>%2F%E7%BB%99%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E7%83%AD%E9%99%8D%E9%99%8D%E6%B8%A9%2F</url>
    <content type="text"><![CDATA[今天下午也算兴致所至，与好友到学校图书馆的报告厅里听了一场题为“关于无人驾驶车辆的几点思考”的报告，主讲人是南京理工大学的杨教授，算是科普介绍类型的，不是很学术。总感觉这种报告如果不作记录，只是过过耳瘾的话，收获微乎其微，因此决定动动脑子提提笔。 这是一场规模较小的专题报告，因此报告厅不是很大，但是基本坐满了陆陆续续来的老师和同学们。大概3时许，经过主持人的介绍，一位头发花白的八旬老翁走上了讲台，这就是今天的主讲人杨教授，也算是国内比较早就研究无人驾驶的先驱了。 他简要回顾了一下无人驾驶车辆的发展历程，最早的无人驾驶车辆还属于遥控车辆，需要操作手在一定范围内根据传回的视频图像进行操作，之后到了八十年代，美国军方开始考虑发展自主车辆，也就是说借助机器智能让车辆在复杂路况中行驶，不需要借助人的干预。印象比较深刻的是由美国DRAPA资助的无人驾驶越野比赛，要求无人车辆根据GPS引导自主穿越200KM的荒漠地形。2004年的时候最好的车辆只行驶了11KM就gg了，但是2005年的时候得益于硬件传感器-激光雷达的突破，有6个车辆团队完成了这一极具挑战的任务，其中由后来谷歌无人之父Sebastian Thrun带领的斯坦福团队出乎意料的摘得了桂冠，这个突破是无人驾驶的一个重要里程碑，也才有后来谷歌无人驾驶、Tesla的Model S等等。我之前看过这次比赛的纪录片，很有意思，因此推荐大家可以找来看看。 杨教授主要是研究军用的无人驾驶车辆，并且在介绍中给我们展示了一些他和团队的研究成果，比如履带无人驾驶车、高速公路行驶的无人车、疲劳驾驶检测等。民用无人驾驶希望解放人类驾驶员，减少交通事故的发生，主要是在结构化环境也就是有车道线、红绿灯等的环境中行驶，采用的技术结合了GPS和弱的机器视觉，由于道路环境相对固定，因此通过深度学习得到足够好的环境建模就能应用于生活中的许多场景，机器视觉主要用于一些突发状况的检测。军用中则是为了减少人员伤亡，所以追求车辆的无人化，并且要适用于非结构化的野外复杂地形，采用的技术主要是GPS结合强机器视觉，由于道路环境的不确定和复杂性，环境建模并不好适用。即使是美国老大哥，军用无人驾驶车辆的发展也不尽如人意。 下图是智能汽车等级目前的行业SAE标准，目前无人驾驶的发展阶段主要在L2~L3级，还是需要驾驶员来观察环境如红绿灯和应对突发环境如突然横穿马路的行人等。 杨教授认为无人驾驶仍然有很长的路要走，有很多因素需要考虑。比如目前普遍采用的激光雷达不仅价格昂贵，而且得到的信息还不充分；针对特定道路开发的算法在不同道路状况下不够稳健等。技术上不成熟只是一个方面，还有许多相关的法律法规的问题需要解决，比如无人驾驶在公开道路测试的安全性问题、发生事故的责任认定等等，此外还有车联网配套的基础设施建设等。在无人驾驶热浪滚滚的今天，杨教授似乎显得格外冷静，这可能跟他长期研究无人驾驶车辆的经历有关。他认为目前安全是民用汽车行驶的第一重要因素，无人驾驶需要在算法、道路基础设施、网络的安全都得到保障的基础上才能够真正的安全。因此主动安全在目前的民用汽车行驶中应该更贴近需要，比如车道线保持、车距保持、障碍物预警、疲劳驾驶检测、视觉能见度增强等，主动安全能够有效减少交通事故的发生。 现场的观众就无人驾驶的视觉传感器（选用可见光传感器或者激光雷达）的优劣、无人驾驶的安全如何保障、V2X等问题与杨教授进行了交流，丰富了这次报告的内容。 不知不觉，扯皮扯的有点多，不过做了总结和整理，也算加深了认识，之后学习Udacity的无人驾驶课程相信我也会更加理性，与君共勉！]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Anaconda管理python开发环境]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Anaconda%E7%AE%A1%E7%90%86python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[这篇博客用来记录Udacity无人驾驶课程的环境搭建，以减少不必要的重复劳动。 参考链接：Configure and Manage Your Environment with AnacondaAnaconda and Jupyter Notebooks Windows系统 我的系统是win10 64位的，所以下载Windows-x86_64版的miniconda，安装成功后打开Anaconda Prompt。接下来就可以搭建carnd-term1环境了： git clone https://github.com/udacity/CarND-Term1-Starter-Kit.git cd CarND-Term1-Starter-Kit 进入CarND-Term1-Starter-Kit目录后，将meta_windows_patch.yml重命名为meta.yml。然后执行 conda env create -f environment.yml 就可以按照environment.yml文件创建carnd-term1环境，用conda info –envs可以查看是否创建成功，如果你需要卸载这个环境，执行： conda env remove -n carnd-term1 之后我们需要运行一些代码来测试： git clone https://github.com/udacity/CarND-Term1-Starter-Kit-Test.git cd CarND-Term1-Starter-Kit-Test 进入carnd-term1环境并运行jupyter notebook来验证安装的包是否可以正常工作 activate carnd-term1 jupyter notebook test.ipynb 浏览器会自动跳转到 http://localhost:8888/notebooks/test.ipynb 网址，我在测试中发现缺少requests模块, 所以就手动安装： conda install requests 解决了这个问题，经测试，jupyter notebook的每个单元都能够正常执行，没有错误，说明Windows环境下的carnd-term1已经完全ok了。效果图如下：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过tor浏览器匿名上网]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87tor%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8C%BF%E5%90%8D%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[搭建梯子，科学上网 这里不做过多介绍，具体可以参考这篇博客VPS从选购到配置SS客户端全过程介绍！ 当你实现科学上网之后，你的SS客户端的代理端口配置为1080，如下图： 配置tor浏览器，匿名上网 到tor官网下载并安装tor浏览器，我这里下的是torbrowser-install-7.5.3_zh-CN.exe（windows，简体字版本), 下载安装过程比较简单，不多说了。安装好后，出现如下界面： 由于网络审查的原因，无法直接连接，点击配置后，勾选使用代理访问互联网代理类型SOCKS5,地址127.0.0.1，端口1080，用户名密码可不填，此时使用的代理就是你科学上网的VPS，（值得一提的是，勾选我所在国家对Tor进行了封锁，选中选择内置网桥这项的meek开头的网桥有时候也可用，只是网速就呵呵了），如下图： 然后点击连接，就会出现如下界面： 如果出现了如下的界面，就表示连接成功，可以匿名上网了： 当然，如果没有成功，tor日志中会打印错误信息，可点击复制粘贴到记事本中查看。这时侯就要检查你的VPS是否能科学上网，SS客户端是否配置正确，tor浏览器配置是否有误等…… 安全访问暗网信息 暗网中使用的网址很多是.onion结尾的（有些可能已经无法访问），可以通过tor浏览器进行访问，tor浏览器默认使用DuckDuckGo浏览器，你也可以使用别的浏览器如torch、not evil等，常用门户网站如下： https://www.deepwebsiteslinks.com/ https://thehiddenwiki.org/ 其它的日后再补充……友情提醒：访问暗网时，可能会遇到各类违法犯罪的网站，不可参与，可能有钓鱼执法哦，满足好奇心过过眼瘾即可，切勿沉迷！]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>tor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器是否会取代人类]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E6%98%AF%E5%90%A6%E4%BC%9A%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[最近一段时间读了凯文·凯利的《失控》和 Charles Petzold 的《图灵的秘密》，觉得颇有意思，为它们独特的思想所吸引。 我想，如果让凯文·凯利和图灵来回答“机器是否会取代人类”这个问题，同样也会很有趣。（下面纯属臆想，如有雷同，怎么可能！） 凯文·凯利：嗯，我想这大概不会是一个问题，机器与人类之间的关系几乎从一开始就是共生共栖的。它们在未来一定会共同进化，共同分享这个世界，因为他们互相谁也取代不了。。。 阿兰·图灵：我觉得没有必要区分人和机器，都是机器，这个问题不存在的。。。 维纳见状，异常兴奋：你们这就完了，看来还是太年轻啊，还是我来证明一下吧……接着就是一堆看不懂的符号公式，但是从此再也没有人敢问这个问题了，哈哈。。。]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>人与机器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32之寄存器访问]]></title>
    <url>%2FSTM32%E4%B9%8B%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[一般的寄存器访问需要通过读-改-写三步曲 和 位运算的清0置1来实现，但在stm32的编程中，通过利用它的一些优秀的特性如端口位设置/复位寄存BSRR、位绑定等，我们可以大大提升寄存器的访问速度和简化寄存器的操作。 123//一般寄存器操作：GPIOx-&gt;ODR |= 0x10; //Pin4置1GPIOx-&gt;ODR &amp;= ~0x10; //Pin4清0 BSRR/BRR寄存器 12GPIOx-&gt;BSRR //对BSRR的低16位写1置位，对BSRR的高16位写1清零GPIOx-&gt;BRR //对BRR的低16位写1清零，BRR的高16位保留 由此可见，通过BSRR/BRR寄存器来操作ODR寄存器， 不需要 读-改-写三步曲， 仅通过 写 就可一步到位，方便不少。 位绑定当然了，stm32还有一个更牛X的特性–位绑定，仅仅只要1个时钟周期就能实现单独的位操作。位绑定，是通过简单的地址变换将寄存器中的某一个位映射到内存中的某一个存储单元。这样通过对一个内存单元的读写就能间接访问相应寄存器的某个位了，当然此时该32位的内存单元也只有最低位是有效的啦！ 1234567891011但是整个M3内核并没有全部允许位绑定，只有两个区有，分别是SARM：0x20000000~0x2000FFFF 1M大小 这个区绑定的地址是从0x22000000开始的； PERIPHERALS：0x40000000~0x4000FFFFF 1M大小这个区绑定的地址是从0x42000000开始的；对应的位绑定公式为： SRAM：AliasADDr = 0x22000000+((A-0x20000000)*32+n*4)其中A：0x20000000~0x2000FFFF n：0~31PERIPHERALS: AliasADDr = 0x42000000+((A-0x40000000)*32+n*4)其中A：0x40000000~0x4000FFFFF n：0~31 下面就可以通过位绑定来快速实现位操作 12345678910#define GPIOA_ODR_ADDR (GPIOA_BASE + 0x0C)#define GPIOA_IDR_ADDR (GPIOA_BASE + 0x08)#define BitBind(Addr, bitNum) (*(volatile unsigned long *)((Addr&amp;0xF0000000)+0x2000000+((Addr&amp;0xFFFFF)&lt;&lt;5)+(bitNum&lt;&lt;2)))//Addr&amp;0xF0000000是为了区分SRAM还是PERIPHERALS//Addr&amp;0xFFFFF相当于(A-0x20000000)或者(A-0x40000000)//左移是为了实现快速的乘法操作：左移n位相当于乘以2^n#define PAout(n) BitBind(GPIOA_ODR_ADDR, n) #define PAin(n) BitBind(GPIOA_IDR_ADDR, n) 这样就实现了类似51单片机访问I/O的操作方式 1234sbit P10 = P1^0P10 = 0; 或 P10 = 1;PAout(3) = 1; 或 PAout(3) = 0; Pretty cool, huh!]]></content>
      <categories>
        <category>电子</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32之SPI通信]]></title>
    <url>%2FSTM32%E4%B9%8BSPI%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[之前一直对SPI通信一知半解，所以想抽空把它搞得明白一些。考虑到之前是结合Flash芯片来学的，十分不直观，而且主要把时间和精力都花在Flash芯片的datasheet和驱动上了，SPI通信也没学好。所以这次就考虑用4位数码管显示模块，模块是直接买的现成的，如下图所示，这样可以简化操作，把精力聚焦到学习的核心–SPI通信本身上来。该模块是用2片74HC595串联驱动的，一片用来控制数码管的位选(U1)，一片用来控制数码管的段选(U2)。接口比较简单，总共5个引脚，2个引脚分别接VCC和GND，DIO用来接收串行数据的输入，SCLK用来接收同步时钟，每个SCLK上升沿74HC595内部的移位寄存器会移一位，RCLK用来控制数据的输出，每个RCLK上升沿74HC595内部的移位寄存器的数据会被放进存储寄存器并输出到外部引脚QA~QH上。而QH’是串行输出引脚，该引脚会接收最高位的溢出，从而实现多片74HC595的级联。当两片74HC595串联时，先发八位数据用于段选，再发八位数据用于位选，然后RCLK上升沿，就可以驱动某位数码管显示某个字符，通过动态扫描数码管，由于人眼的视觉暂停效果，就可以实现4位数码管的同时显示。先用通用I/O来实现该数码管的驱动，程序如下：头文件74HC595.h1234567891011121314151617181920#ifndef __74HC595_H__#define __74HC595_H__#include"stm32f10x_lib.h" //包含所有的头文件#include&lt;stdio.h&gt;// 4-Bit LED Digital Tube Module#define HC595_SCLK_PIN GPIO_Pin_5 // SPI1_SCK PA5#define HC595_RCLK_PIN GPIO_Pin_12 // SPI1_NSS PA4#define HC595_DIO_PIN GPIO_Pin_7 // SPI1_MOSI PA7#define HC595_GPIO GPIOA #define HC595_RCLK_GPIO GPIOB #define HC595_RCC RCC_APB2Periph_GPIOA #define HC595_RCLK_RCC RCC_APB2Periph_GPIOB void HC595_Init(void);void HC595_SendByte(u8 data);u8 HC595_Display(u16 num, u8 dp);#endif 源文件74HC595.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// 用于HC595实现的4Bit-LED Digit Tube Module// 注意：该4位数码管是共阳的！#include "74HC595.h"// 码表const u8 digitTable[] = &#123;// 0 1 2 3 4 5 6 7 8 9 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90,// A b C d E F - 0x8C, 0xBF, 0xC6, 0xA1, 0x86, 0xFF, 0xbf&#125;;/******************************************************************************** Function Name : HC595_Init* Description : 初始化HC595* Input : None* Output : None* Return : None*******************************************************************************/void HC595_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量 RCC_APB2PeriphClockCmd(HC595_RCC | HC595_RCLK_RCC, ENABLE); //使能HC595的时钟 //74HC595, SCLK RCLK DIO 推挽输出 GPIO_InitStructure.GPIO_Pin = HC595_SCLK_PIN| HC595_DIO_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //管脚频率为50MHZ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //输出模式为推挽输出 GPIO_Init(HC595_GPIO, &amp;GPIO_InitStructure); //初始化寄存器 GPIO_InitStructure.GPIO_Pin = HC595_RCLK_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //管脚频率为50MHZ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //输出模式为推挽输出 GPIO_Init(HC595_RCLK_GPIO, &amp;GPIO_InitStructure); //初始化寄存器 &#125;/******************************************************************************** Function Name : HC595_SendByte* Description : 发送一个字节* Input : data* Output : None* Return : None*******************************************************************************/void HC595_SendByte(u8 data)&#123; u8 i; for (i=8; i&gt;=1; i--) &#123; // 高位在前 if (data&amp;0x80) GPIO_SetBits(HC595_GPIO, HC595_DIO_PIN); else GPIO_ResetBits(HC595_GPIO, HC595_DIO_PIN); data &lt;&lt;= 1; // SCLK上升沿 GPIO_ResetBits(HC595_GPIO, HC595_SCLK_PIN); GPIO_SetBits(HC595_GPIO, HC595_SCLK_PIN); &#125;&#125;/******************************************************************************** Function Name : HC595_Display* Description : 显示4位数字(包括小数点)* Input : num: 0000 - 9999 * dp: 小数点的位置1-4 * Output : None* Return : 正常返回0，错误返回1*******************************************************************************/u8 HC595_Display(u16 num, u8 dp)&#123; u8 qian = 0, bai = 0, shi = 0, ge = 0; // 对显示的参数范围进行检查 if (num &gt; 9999 || dp &gt; 4) //报错 return 1; // 对num进行分解 qian = num / 1000; bai = num % 1000 / 100; shi = num % 100 / 10; ge = num % 10; // 千位 if(dp == 1) HC595_SendByte(digitTable[qian] &amp; 0x7F); else HC595_SendByte(digitTable[qian]); HC595_SendByte(0x08); GPIO_ResetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); GPIO_SetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); // 百位 if(dp == 2) HC595_SendByte(digitTable[bai] &amp; 0x7F); else HC595_SendByte(digitTable[bai]); HC595_SendByte(0x04); GPIO_ResetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); GPIO_SetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); // 十位 if(dp == 3) HC595_SendByte(digitTable[shi] &amp; 0x7F); else HC595_SendByte(digitTable[shi]); HC595_SendByte(0x02); GPIO_ResetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); GPIO_SetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); // 个位 if(dp == 4) HC595_SendByte(digitTable[ge] &amp; 0x7F); else HC595_SendByte(digitTable[ge]); HC595_SendByte(0x01); GPIO_ResetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); GPIO_SetBits(HC595_RCLK_GPIO, HC595_RCLK_PIN); return 0;&#125; 接下来就可以把重心都放在STM32的SPI外设上了，首先需要读一下STM32F10x的参考手册的SPI（串行外设接口）部分，这样对SPI就可以有较好的理解，比较重要的是要看懂SPI的结构框图和主从机通信的示意图，如下： 这个理解以后，我们就可以参考《STM32F103XX固件库用户手册》的SPI部分来实现STM32的SPI外设配置和收发数据了，具体代码如下：头文件74HC595_SPI.h1234567891011121314151617181920212223242526#ifndef __74HC595_SPI_H__#define __74HC595_SPI_H__#include"stm32f10x_lib.h" //包含所有的头文件#include&lt;stdio.h&gt;// 4-Bit LED Digital Tube Module// 引脚 // SPI1 4位数码管 #define HC595_NSS_PIN GPIO_Pin_4 // SPI1_NSS 未用#define HC595_SCK_PIN GPIO_Pin_5 // SPI1_SCK SCLK#define HC595_MISO_PIN GPIO_Pin_6 // SPI1_MISO 未用 #define HC595_MOSI_PIN GPIO_Pin_7 // SPI1_MOSI DIO#define HC595_RCLK_PIN GPIO_Pin_12 // RCLK// 端口#define HC595_SPI1_GPIO GPIOA #define HC595_RCLK_GPIO GPIOB // 时钟#define HC595_SPI1_RCC RCC_APB2Periph_GPIOA#define HC595_RCLK_RCC RCC_APB2Periph_GPIOB void HC595_Init(void);void HC595_SendByte(u8 data);u8 HC595_Display(u16 num, u8 dp);#endif 源文件74HC595_SPI.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************省略部分代码见(74HC595.c)************************//******************************************************************************** Function Name : HC595_Init* Description : 初始化HC595* Input : None* Output : None* Return : None*******************************************************************************/void HC595_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; SPI_InitTypeDef SPI_InitStructure; // 声明一个结构体变量 // 不需要开启AFIO时钟 RCC_APB2PeriphClockCmd(HC595_SPI1_RCC | HC595_RCLK_RCC | RCC_APB2Periph_SPI1, ENABLE); // 使能HC595及SPI1的时钟 //74HC595, SPI1_NSS、SPI1_SCK、SPI1_MOSI GPIO_InitStructure.GPIO_Pin = HC595_NSS_PIN | HC595_SCK_PIN |HC595_MOSI_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 管脚频率为50MHZ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 输出模式为复用推挽输出 GPIO_Init(HC595_SPI1_GPIO, &amp;GPIO_InitStructure); // 初始化寄存器 //74HC595, SPI1_MISO GPIO_InitStructure.GPIO_Pin = HC595_MISO_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // 输入模式为浮空输入 GPIO_Init(HC595_SPI1_GPIO, &amp;GPIO_InitStructure); // 初始化寄存器 //74HC595, RCLK GPIO_InitStructure.GPIO_Pin = HC595_RCLK_PIN; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // 管脚频率为50MHZ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 输出模式为复用推挽输出 GPIO_Init(HC595_RCLK_GPIO, &amp;GPIO_InitStructure); // 初始化寄存器 /* Initialize the SPI1 according to the SPI_InitStructure members */ SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; // 第一步：设置主从模式和通信速率 SPI_InitStructure.SPI_Mode = SPI_Mode_Master; // SPI_NSS_Hard时需要外部电路把NSS接VCC, SPI_NSS_Soft时SPI外设会将SSM和SSI置位 SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; // 实测波特率最低为SPI_BaudRatePrescaler_8，否则出错 SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; // 第二步：设置数据格式 SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; // MSB在前还是LSB在前要根据码表和数码管与74HC595的接法来定 SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; // 第三步：设置时钟和极性 // 当SPI_CPOL_Low且SPI_CPHA_2Edge出错 SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low; SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge; //第四步：其它，CRC校验，可靠通信，这步可以不设置 SPI_InitStructure.SPI_CRCPolynomial = 7; SPI_Init(SPI1, &amp;SPI_InitStructure); /* Enable SPI1 */ SPI_Cmd(SPI1, ENABLE);&#125;/******************************************************************************** Function Name : HC595_SendByte* Description : 发送一个字节* Input : data* Output : None* Return : None*******************************************************************************/void HC595_SendByte(u8 data)&#123; SPI_I2S_SendData(SPI1, data); while(!SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE));&#125;/************************省略部分代码(见74HC595.c)************************/ 这样就大工告成啦，STM32的SPI外设还是比较简单的，尤其是通过库函数来调用。用数码管模块这种简单的可视化工具，我们就可以更好的研究通信协议本身的特性啦，后续我还会用这种方式来学习其它的通信协议，好了，”talk is cheap, show me the code”!]]></content>
      <categories>
        <category>电子</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言之递归]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[我将这篇博文的代码托管在了Github上，分别是fabonacci.c(斐波那契数列问题） 和 hanoi.c（汉诺塔问题）。获取源码： git clone git@github.com:hewangxing/data-struct.git 递归理解：递归是一个自相似并不断重复的过程，在程序中呈现为一种函数在定义时调用自身的方法。递归的特征：1.有一个参考值作为基准，使得递归过程可以在有限步骤结束并获得确定的结果。2.问题可以分解为更小且相同的部分。（难点）递归常用在有递推公式、迭代方程等的类似问题中。 递归的大致过程： 递归函数（输入） { if 符合基准情况 return 基准情况下问题的解 输入 = 分解成更小但重复的问题 递归函数（输入） } 一、斐波那契数列问题： 观察以下数列： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 …… 数列的第0项和第1项的值分别为：0和1。后续第N项的值的为第N-1项的值与第N-2的值之和。 求一个递归函数来求斐波那契数列上第N项的值。 /* * descrip: a recursion exercise, fabonacciv sequence * author: xingyes * date: 2017-05-01 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /*long long fabonacciv(int n) { if(n == 0) return 0; else if(n == 1) return 1; else return fabonacciv(n-1) + fabonacciv(n-2); }*/ long long sequence(int n, long long t0, long long t1) { if(n == 0) return t0; else if(n == 1) return t1; else return sequence(n-1, t1, t0+t1); } long long fabonacciv(int n) { return sequence(n, 0, 1); } int main(int argc, char *argv[]) { if(argc != 2) { fprintf(stderr, &quot;Usage: %s N.\n&quot;, argv[0]); return 0; } int n = atoi(argv[1]); fprintf(stdout, &quot;%d %lld\n&quot;, n, fabonacciv(n)); return 0; } 二、汉诺塔问题 有三根杆子A，B，C。A杆上有N个(N&gt;1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆： 1.每次只能移动一个圆盘。2.大盘不能叠在小盘上面。 问题可以分解成三步：（以三个盘为例） /* *descrip: a recursion exercise, solution for hanoi *author: xingyes *date: 2017-05-01 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void moveSingleStep(int disk, char A, char B, char C) { static int step = 1; fprintf(stdout, &quot;step%d: disk%d %c--&gt;%c\n&quot;, step++, disk, A, C); } void hanoi(int n, int disk, char A, char B, char C) { if(n == 1) moveSingleStep(disk, A, B, C); else { hanoi(n-1, disk-1, A, C, B); hanoi(1, disk, A, B, C); hanoi(n-1, disk-1, B, A, C); } } int main(int argc, char *argv[]) { if(argc != 2) { fprintf(stderr, &quot;Usage: %s N.\n&quot;, argv[0]); return 0; } int n = atoi(argv[1]); fprintf(stdout, &quot;========hanoi(%d)\n&quot;, n); hanoi(n, n, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;); fprintf(stdout, &quot;========hanoi finished\n&quot;); return 0; }]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进阶命令]]></title>
    <url>%2FLinux%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[(1) find作用: 在Linux文件系统中，用于查找某个文件所在绝对路径。 find 搜索路径 -name &quot;文件名&quot; //这里的搜索路径(绝对路径)越详细越好，可以加快查找的速度。 //例如: find /home -name &quot;hello.c&quot; (2) grep作用: 用于查找某个符号在某些文件中(比如某个单词)的位置。 grep 参数 &quot;符号名称&quot; 某个文件或文件夹 例如：grep -rn &quot;main&quot; * //-r 递归查找、-n 打印行号、* 当前目录 //表示在当前目录递归查找main这个符号出现的位置，并打印行号 (3) which/whereis作用：查找某个命令或者应用程序(二进制文件)的位置。 which/whereis 命令或应用程序名 //区别: which只打印二进制文件所在的路径，而whereis打印二进制文件、源码和man手册的路径，更详细一些! (4) uname作用: 打印系统信息。 uname -a //打印系统的所有信息，包括内核版本，日期，操作系统等 uname -r //打印内核版本的信息 uname -p //打印CPU的信息 uname 或者 uname -s //打印内核名字，比如Linux (5) mount/umount 作用：挂载/卸载磁盘到Linux文件系统的某个目录上, 以便对磁盘的进行访问。 (6) shutdown/init作用：关机、重启Linux系统。 shutdown -h now //立即关机 shutdown -r now //立即重启 init 0 //关机 init 2 //重启 (7) chmod/chown/chgrp作用：对文件的权限(读写、执行、拥有者等)进行管理。 chmod (change mode, 修改文件的读写、执行权限) chown (change owner, 修改文件的拥有者) chgrp (change group, 修改文件的拥有者所在的组) chmod对文件的读写、执行权限进行修改有两种方式： ① 用数字编码的方式修改文件的所有权限: chmod 编码值 文件名 &apos;r&apos; 可读 4 &apos;w&apos; 可写 2 &apos;x&apos; 可执行 1 &apos;-&apos; 无权限 0 //例如 chmod 777 文件名 可修改权限值为-rwxrwxrwx ② 只修改文件的部分权限 -rwxr-xr-x //文件的拥有者u(user)、文件拥有者所在的组g(group)、其它用户o(other)，+增加权限，-减少权限 例如：chmod u+x 文件名 //让用户的拥有者具有可执行权限 chown/chgrp对文件的拥有者和所在的组进行修改： chown 拥有者 文件名 chgrp 拥有者所在的组 用户名 (8) tree作用：可以很直观的打印出文件/目录的树形结构，不是Linux自带的命令，需要下载安装才能使用。 tree 文件/目录 //tree默认打印当前的文件/目录的树形结构 (9) tar作用: 对文件夹打包和解压缩包。 tar czvf abc.tar.gz abc/ //将abc文件夹打包成abc.tar.gz tar xzvf abc.tar.gz //将abc.tar.gz解压到当前目录 tar cjvf abc.tar.bz2 abc/ //将abc文件夹打包成abc.tar.bz2 tar xjvf abc.tar.bz2 //将abc.tar.bz2解压到当前目录]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[(1) ls (list, 列表)作用：用来查看当前目录下具体有哪些文件，及文件的相关信息。 ls ls -a //(all，查看所有的文件，包括隐藏文件. ..) ls -l //(查看文件的详细信息，如文件大小、创建时间、权限等） ls -a -l ls -l -a ls -al ls -la //(四种方式等价，都可以用来查看当前目录下所有文件的详细信息) (2) cd (chang directory, 更改目录)作用: 用来更改当前的工作目录。切换目录类型：① 绝对路径：以根文件夹/为起始的完整路径。(Windows下则是以盘符如C:\开始的)② 相对路径：相对于当前文件夹的路径。 . //当前文件夹 .. //上一级文件夹 //可以通过“../../”这种级联的方式回退到更上一级的文件，到根文件夹/为止 //每个文件夹下都有隐藏的2个文件夹“.”和“..” ，用来实现这种机制 ~ //当前用户目录 (3) pwd (print working directory, 打印工作目录)作用：打印出当前的工作目录的绝对路径。 (4) mkdir (make dirctory, 创建目录)作用: 在当前目录下创建空目录。 mkdir 目录文件名 mkdir -p 多级目录名 //创建级联目录，目录中包含子目录。 (5) mv (move, 移动文件) 作用: 在文件夹之间移动文件或重命名文件名，其实质就是对全路径进行修改。 mv 源文件(全路径) 目标文件(全路径) //把一个目录下文件移动到另一个目录,相当于Windows下的剪切+粘贴 mv 源文件名 目标文件名 //重命名 (6)touch (创建文件)作用：在当前目录下创建空文件。 touch 文件名 (7)cp (copy, 复制文件)作用: 把一个目录下的文件复制粘贴到另一个目录下。 cp 源文件(全路径) 目标文件(全路径) //把一个目录下文件复制到另一个目录,相当于Windows下的复制+粘贴，在粘贴的同时可以修改文件名 cp -f //强制复制文件，意味着复制的同时可以覆盖同名文件 cp -r //复制文件夹，包括级联的文件夹 //一般情况下，用cp -f复制文件， cp -rf复制文件夹。 (8)rm (remove, 移除，删除)作用: 用来删除文件或者文件夹。 rm 源文件(全路径) //将文件在磁盘中删除 rm -r 删除文件夹(全路径) //不管文件夹是否空文件夹都可以删除 rm -f 强制删除 //即使文件不存在也不会报错 (9)cat作用: 用来在命令行显示文件的内容，适合行数不多的文件，也可以将内容输入到文件中。 cat 文件名(全路径) //在命令行中显示文件内容 cat 源文件名(全路径) &gt; 目标文件名(全路径) //通过重定向将源文件内容输入到目标文件中 (10)rmdir (remove directory, 删除文件夹)作用: 只能删除空文件夹(即使文件夹中只有一个空文件夹也不行)，作用和rm -r有所重复。 (11) ln (link, 链接文件) ① 软链接，又叫符号链接，相当于windows的桌面快捷方式，是用一个文件（链接文件）访问另一个文件（源文件）的方式， 链接文件是附属于源文件的，删除链接文件并不会影响源文件，但删除源文件将会导致链接文件失效。 ln -s 源文件 链接文件 ② 硬链接，也是用一个文件（链接文件）访问另一个文件（源文件）的方式，但是与软链接机制不同，硬链接文件和源文件是等价的，且实际对应磁盘上同一个文件，只有同时删除硬链接文件和源文件，文件内容才会被删除 ln 源文件 链接文件 文件类型和文件权限： -rwxrw-r-- //共10个字符，第1个字符表示文件类型，其它9个字符表示文件权限 1. - //普通文件，包括文本文件和二进制文件 2. d //文件夹，directory 3. l //软(符号)链接文件 4. s //socket文件，网络 5. p //pipe管道文件，进程间通信 //文件权限可分为三段：用户(user)、群组(group)、其它用户(others), 其中用户是文件的所有者，群组是该用户所属的组，不属于该群组的为其它用户 //每段三个字符，其中r表示可读(read)、w表示可写(write)、x表示可执行(execute)、-表示无该权限 (12) man (Reference Manual，参考手册)作用：Linux的离线帮助手册，可以用来查阅linux相关的命令、编程等信息 man 1 xxx //用来查阅linux的命令（User Commands） man 2 xxx //用来查阅Linux的API（Linux&apos;s Programmer&apos;s Manual） man 3 xxx //用来查阅C库函数（Linux&apos;s Programmer&apos;s Manual） (13) apt-get (apt软件管理器)作用: 适用于ubuntu系统，用来在线安装、更新、卸载软件，需要联网和root权限。 apt-get install xxx //安装、更新软件 apt-get remove xxx //卸载软件 说明: linux由于内核版本、发行版众多，可能会导致各种软件不兼容的问题。所以ubuntu提供了apt软件管理器解决了这个问题。 当用apt-get向相应的服务器发出安装软件请求时，服务器会在列表中寻找适合该系统的软件包，如果找到就会下载安装，否则就会提示找不到。 (14) su作用: 可以在不同的用户之间进行切换。 su 用户名 //Linux只有一个特权用户(root用户)，但是有多个普通用户，通过su root或者su可以切换到root用户(需要输入root密码)， //在普通用户之间切换也需要密码，但从root用户切换到普通用户可以不用输入密码 (15) sudo作用：ubuntu中，通过sudo命令可以让普通用户暂时获得root权限，而不必在普通用户和root用户之间进行切换， 比较方便。 比如sudo apt-get install xxx]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作在寄存器中的作用]]></title>
    <url>%2F%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[寄存器是用来管理硬件的，所以读写寄存器就是操纵硬件。怎么操纵寄存器? 三部曲读改写，读改写的意思，就是先把寄存器的值读出来，修改寄存器中部分位的内容后再写回到寄存器中去。 由于我们操作寄存器时往往只需要修改寄存器的特定几位就可以了(其它位不能改变)，但是寄存器只能按照比如32位来整个进行读写， 并不能只读写寄存器中特定的一些位，这里就产生了一个矛盾, 那怎么解决这个问题呢？ 常用的方法有以下3种： 1、位与&amp;可以用来清零某些位而不改变其它位 位与：任何数（0或1）与0相与为0， 与1相与为它自己,所以只要寄存器中的数的某些位与0相与，其它位与1相与即可 //位与&amp;清零寄存器中的BIT4~BIT7位而不改变其它位 unsigned int a = 0x1234ABCD, b = 0xFFFFFF0F; unsigned int c; c = a &amp; b; //0x1234AB0D printf(&quot;c = 0x%x\n&quot;, c); 2.位或|可以用来置1某些位而不改变其它位 位或|：任何数（0或1）与1相或为1，与0相或则为它自己。 //位或|置1寄存器中的BIT8~BIT15位而不改变其它位 unsigned int a = 0x1234ABCD, b = 0x0000FF00; unsigned int c; c = a | b; //0x1234FFCD printf(&quot;c = 0x%x\n&quot;, c); 3.位异或^可以用来取反某些位而不改变其它位 位异或^: 任何数（0或1）与1异或则取反，与0异或则为它自己。 //位异或^取反寄存器中的BIT8~BIT11位而不改变其它位 unsigned int a = 0x1234ABCD, b = 0x00000F00; unsigned int c; c = a ^ b; //0x1234A4CD printf(&quot;c = 0x%x\n&quot;, c); 用位与&amp;、位或|、位异或^可以分别用来对寄存器的某些位进行清理、置1、取反操作，但是需要构建一个32位的由0和1构成的数来满足我们的要求 ，比较麻烦，需要依赖软件工具、计算器或者大脑来计算得到，不是很直观，因为不好理解，代码的可读性会变差, 所以可以通过以下方法构造特定二进制数来实现。 4.通过移位（&lt;&lt;或&gt;&gt;）和位或来实现。 //构造一个bit7~bit12是1，其余位全是0的数 (0x3F&lt;&lt;7) //构造一个bit0~bit2、bit7~bit12、bit18~bit21为1，其余位全是0的数 ((7&lt;&lt;0)|(0x3F&lt;&lt;7)|(0xF&lt;&lt;18)) 代码实现： //构造一个bit7~bit12是1，其余位全是0的数 unsigned int a; a = (0x3F&lt;&lt;7); //0x1F80 printf(&quot;a = %x.\n&quot;, a); //构造一个bit0~bit2、bit7~bit12、bit18~bit21为1，其余位全是0的数 unsigned int a; a = ((7&lt;&lt;0)|(0x3F&lt;&lt;7)|(0xF&lt;&lt;18)); //0x3C1F87 printf(&quot;a = %x.\n&quot;, a); 5.通过取反和移位来构造特定的二进制数 //构造一个bit5~bit9是0，其余位全是1的二进制数 //方法一：(0x1F&lt;&lt;0)|(0x7FFFFF&lt;&lt;10) 用移位&lt;&lt;和或|操作实现，比较笨的方法 //方法二：~(0x1F&lt;&lt;5) 先构建一个位反数，然后取反得到,比较聪明的方法 代码实现： //构造一个bit5~bit9是0，其余位全是1的二进制数 //方法一：比较笨的方法 unsigned int a; a = (0x1F&lt;&lt;0)|(0x7FFFFF&lt;&lt;10); //0xFFFFFC1F printf(&quot;a = %x.\n&quot;, a); //方法二：比较聪明的方法 unsigned int b; b = ~(0x1F&lt;&lt;5); //0xFFFFFC1F printf(&quot;b = %x.\n&quot;, b); 一般来说，如果需要构建的二进制数中大多数是0，少数是1，可以通过移位的方法来构造; 如果需要构建的二进制数中大多数是1，少数是0，可以通过移位构建位反数然后取反的方法来构造; 如果有多段连续1的数出现，则可以分段移位然后或起来叠加得到。 6.位操作的相关练习：回顾：要置1用|，用清零用&amp;，要取反用^，~和&lt;&lt;、&gt;&gt;用来构建特定二进制数。 ①给定一个整型数a，设置a的bit3，保证其他位不变。 a |= (1&lt;&lt;3); ②给定一个整型数a，设置a的bit3~bit7，保持其他位不变。 a |= (0x1F&lt;&lt;3); 或者 a |= (0b11111&lt;&lt;3); ③给定一个整型数a，清除a的bit15，保证其他位不变。 a &amp;= (~(1&lt;&lt;15)); ④给定一个整形数a，清除a的bit15~bit23，保持其他位不变。 a &amp;= (~(0x1FF&lt;&lt;15)); ⑤给定一个整形数a，取出a的bit3~bit8。 //保持bit3~bit8的数不变，其它位全部清零。然后再右移3位。 a &amp;= (0x3F&lt;&lt;3); a &gt;&gt;= 3; ⑥用C语言给一个寄存器的bit7～bit17赋值937（其余位不受影响）。 //把bit7~bit17清零或者置1，其余位不变，然后位或或者位与0x3A9 a &amp;= (~(0x7FF&lt;&lt;7)); a |= (0x3A9&lt;&lt;7); ⑦用C语言将一个寄存器的bit7～bit17中的值加17（其余位不受影响）。 b= a &amp;(0x7FF&lt;&lt;7); b &gt;&gt;= 7; b += 17; a &amp;= (~(0x7FF&lt;&lt;7)); a |= (b&lt;&lt;7); ⑧用C语言给一个寄存器的bit7～bit17赋值937，同时给bit21～bit25赋值17. a &amp;= (~((0x7FF&lt;&lt;7) | (0x1F&lt;&lt;21))); a |= ((0x3A9&lt;&lt;7) | (0x11&lt;&lt;21)); 代码验证： //给定一个整型数a，设置a的bit3，保证其他位不变。 unsigned int a = 0; a |= (1&lt;&lt;3); //0x8 printf(&quot;a = 0x%x.\n&quot;, a); //给定一个整型数a，设置a的bit3~bit7，保持其他位不变。 /*unsigned int a = 0; //a |= (0x1F&lt;&lt;3); //0xf8 a |= (0b11111&lt;&lt;3); //0xf8 printf(&quot;a = 0x%x.\n&quot;, a); */ //给定一个整型数a，清除a的bit15，保证其他位不变。 /*unsigned int a = 0xFFFFFFFF; a &amp;= (~(1&lt;&lt;15)); //0xFFFF7FFF printf(&quot;a = 0x%x.\n&quot;, a); */ //给定一个整形数a，清除a的bit15~bit23，保持其他位不变。 /*unsigned int a = 0xFFFFFFFF; a &amp;= (~(0x1FF&lt;&lt;15)); //0xFF007FFF printf(&quot;a = 0x%x.\n&quot;, a);*/ //给定一个整形数a，取出a的bit3~bit8。 /*unsigned int a = 0xFFFF1234; a &amp;= (0x3F&lt;&lt;3); //0x30 a &gt;&gt;= 3; //0x6 printf(&quot;a = 0x%x.\n&quot;, a); */ //用C语言给一个寄存器的bit7～bit17赋值937（其余位不受影响）。 /*unsigned int a = 0xFFFF1234; a &amp;= (~(0x7FF&lt;&lt;7)); a |= (0x3A9&lt;&lt;7); //0xfffdd4b4 printf(&quot;a = 0x%x.\n&quot;, a); */ //用C语言给一个寄存器的bit7～bit17赋值937，同时给bit21～bit25赋值17. /*unsigned int a = 0xFFFF1234, b; b= a &amp;(0x7FF&lt;&lt;7); b &gt;&gt;= 7; b += 17; a &amp;= (~(0x7FF&lt;&lt;7)); a |= (b&lt;&lt;7); //0xffff1ab4 printf(&quot;a = 0x%x.\n&quot;, a); */ //用C语言给一个寄存器的bit7～bit17赋值937，同时给bit21～bit25赋值17. unsigned int a = 0xFFFF1234; a &amp;= (~((0x7FF&lt;&lt;7) | (0x1F&lt;&lt;21))); a |= ((0x3A9&lt;&lt;7) | (0x11&lt;&lt;21)); //0xfe3dd4b4 printf(&quot;a = 0x%x.\n&quot;, a);]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存管理之结构体]]></title>
    <url>%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[1、数据结构是什么？就是用来组织和加工数据的一门学问。数据结构中最重要的就是数据，数据结构本质上就是研究数据在内存中如何组织、处理的问题。 2、数组与内存的关系？为什么引进数组？ 因为有许多意义相关、类型相同的变量如果一个一个定义比较麻烦，也不利于代码的维护。所以就引进了数组这么个数据结构。数组名就是数组首元素的首地址，然后数组可以通过下标访问，因为数组 中元素的类型都是相同的，知道首地址后可以直接推算出任意元素的地址。缺点：1.数组的元素类型必须相同；2.数组的大小必须在定义时给定，且不可更改。 3、结构体与数组、内存的关系？为了将意义相关、类型不同的变量组织在一起，引进了结构体这种数据结构。可以说数组就是结构体的一种特例。比如要定义三个学生的成绩，有2种方法：（1）用数组定义 int grades[3];（2）用结构体定义 struct grades { int grade1; int grade2; int grade3; }; struct grades stu1; 在这种情况下，2种方法都可以，但用数组更简洁方便。如果定义的数据结构中的变量类型不相同，则只能使用结构体而不能使用数组。比如： struct student { int age; char name[20]; int height; }; struct student a; 由于结构体中的变量数据类型不相同，所以不能像数组一样直接用下标访问，需要用a.age这样的方式访问才能找到变量的地址。 4、在结构体中内嵌函数指针实现类（面向对象） C语言是面向过程的，C++、java是面向对象的，C语言也可以实现面向对象，只是比较麻烦，而C++、java的语言本身就实现了这种机制。 struct people { int age; void (* pFunc)(void); //函数指针指向void func（void）这样的函数 }; 在这种情况下结构体中的普通变量可以看做是类中的成员变量，函数指针可以看做是类中的成员函数，所以简单实现了OOP的类封装。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
